# -*- coding: utf-8 -*-
"""IEDP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rXUL7Y1mdLW2RicyqvCHNHGsi0xnYyo9

# Diffusion de la chaleur 1D
"""

import numpy as np
import matplotlib.pyplot as plt

# Paramètres
L = 10.0          # Longueur de la barre
T = 10.0           # Temps final
D = 1      # Coefficient de diffusion
C = 1       # Vitesse de convection

# Discrétisation
Nx = 100          # Nombre de points dans l'espace
Nt = 5000         # Nombre de pas de temps
dx = L / (Nx - 1) # Pas d'espace
dt = T / Nt       # Pas de temps

# Condition de stabilité

gamma = D * dt / dx**2

nu = C * dt / dx
print("Gamma:",gamma,", Nu:", nu)

# Pour le schéma explicite, il faut que D * dt / dx^2 <= 0.5
if gamma > 0.5 or nu > 1:
    raise ValueError("Condition de stabilité non satisfaite : dt est trop grand !")


# Création des grilles d'espace et de temps
x = np.linspace(-L/2, L/2, Nx)
t = np.linspace(0, T, Nt)

# Initialisation de la solution
u = np.zeros((Nx, Nt))

def u_exacte(x,t):
    return np.sin(np.pi * x) * (1+t)

# Condition initiale (température initiale)
u[:, 0] = u_exacte(x,0)  # (t=0)

#Source
def f(x,t):
    return np.sin(np.pi * x) + (np.pi)**2 * np.sin(np.pi * x) * (1+t) + np.pi * np.cos(np.pi * x) * (1+t)

# Boucle en temps (schéma explicite)
for n in range(0, Nt - 1):
    for i in range(1, Nx - 1):
        u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - nu * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n])

# Visualisation du résultat
plt.figure(figsize=(8, 6))
plt.imshow(u, aspect='auto', cmap='hot', origin='lower', extent=[0, T, -L/2, L/2])
plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
plt.xlabel("Temps")
plt.ylabel("Position")
plt.colorbar(label='Température')
plt.show()

print(u[0])

#Charlotte
import numpy as np
import matplotlib.pyplot as plt

# Paramètres
L = 10          # Longueur de la barre
T = 5           # Temps final
D = 0.1      # Coefficient de diffusion
C = 0.1       # Vitesse de convection

# Discrétisation
Nx = 100         # Nombre de points dans l'espace
Nt = 50        # Nombre de pas de temps
dx = L / (Nx-1) # Pas d'espace

# Condition de stabilité

gamma = 1/4
v = 1/2

dt1 = gamma * (dx**2) / D
dt2 = v * dx / C

dt = min(dt1, dt2)

# Création des grilles d'espace et de temps
x = np.linspace(-L/2, L/2, Nx)
t = np.linspace(0, T, Nt)
u = np.zeros((Nx, Nt))

def u_exacte(x,t):
    return np.sin(np.pi * x) * (1+t)

# Condition initiale (température initiale)
u[:, 0] = u_exacte(x,0)  # (t=0)

#Source
def f(x,t):
    return np.sin(np.pi * x) + D*((np.pi**2) * np.sin(np.pi * x) * (1+t)) + C * (np.pi * np.cos(np.pi * x) * (1+t))

# Boucle en temps (schéma explicite)
for n in range(0, Nt - 1):
    for i in range(1, Nx - 1):
        u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - v * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n])

u[0,n+1]=0
u[-1, n+1]=0

# Visualisation du résultat
plt.figure(figsize=(8, 6))
plt.imshow(u, aspect='auto', cmap='hot', origin='lower', extent=[0, T, -L/2, L/2])
plt.colorbar(label='Température')
plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
plt.xlabel("Temps")
plt.ylabel("Position")
plt.show()

"""# Sinus"""

import numpy as np
import matplotlib.pyplot as plt

# Paramètres
L = 1          # Longueur de la barre
T = 10          # Temps final
D = 0     # Coefficient de diffusion
C = 1       # Vitesse de convection

# Discrétisation
Nx = 100         # Nombre de points dans l'espace
dx = L / (Nx-1) # Pas d'espace

# Condition de stabilité

gamma1 = 1/4
v1 = 1/2

# dt1 = gamma1 * (dx**2) / D
dt2 = v1 * dx / np.abs(C)
dt1 = dt2

dt = min(dt1, dt2)

gamma = D * (dt/(dx**2))
v = C * dt / dx

Nt = int(T // dt)

# Création des grilles d'espace et de temps
x = np.linspace(0, L, Nx)
t = np.linspace(0, T, Nt)
u = np.zeros((Nx, Nt))

def u_exacte(x,t):
    return np.sin(np.pi * x) * (1+t)

# Condition initiale (température initiale)
u[:, 0] = u_exacte(x,0)  # (t=0)

#Source
def f(x,t):
    return np.sin(np.pi * x) + D*((np.pi**2) * np.sin(np.pi * x) * (1+t)) + C * (np.pi * np.cos(np.pi * x) * (1+t))

plt.figure(figsize=(8, 6))
colors = plt.cm.plasma(np.linspace(0, 1, 5+1)); idx = 0  # Génère Nt//5 couleurs distinctes

# Boucle en temps (schéma explicite)
for n in range(0, Nt - 1):
    for i in range(1, Nx - 1):
        u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - v * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n])
    if n % (Nt // 5) == 0:
        plt.plot(x, u[:, n], label=f"Numérique t={t[n]:.2f}", color=colors[idx])
        plt.plot(x, u_exacte(x, t[n]), '--', label=f"Exacte t={t[n]:.2f}", color=colors[idx])
        idx+=1
plt.title("Comparaison solution numérique vs exacte")
plt.xlabel("Position")
plt.ylabel("température")
plt.grid()
plt.show()



# Visualisation du résultat
plt.figure(figsize=(8, 6))
plt.imshow(u, aspect='auto', cmap='hot', origin='lower', extent=[0, T, 0, L])
plt.colorbar(label='Température')
plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
plt.xlabel("Temps")
plt.ylabel("Position")
plt.show()

"""# Fonction gaussienne t*exp(-x*x)
Valeurs aux bords non nulles => on force l'anulation de la dérivée aux bords
"""

import numpy as np
import matplotlib.pyplot as plt

# Paramètres
L = 10          # Longueur de la barre
T = 10           # Temps final
D = 1      # Coefficient de diffusion
C = 0       # Vitesse de convection

# Discrétisation
Nx = 100         # Nombre de points dans l'espace
dx = L / (Nx-1) # Pas d'espace

# Condition de stabilité

gamma_1 = 1/4
v_1 = 1/2

if D == 0 and C == 0:
    print("Attention aux résultats : valeurs de convection et dispersion non prévues (C=D=0)")
dt1 = gamma_1 * (dx**2) / D if(D != 0) else float('inf')
dt2 = v_1 * dx / np.abs(C) if(C != 0) else float('inf')
dt = min(dt1, dt2)

gamma = dt * D / (dx**2)
v = dt * C /dx
Nt = int(T // dt)

if gamma > 0.5 or v > 1:
    raise ValueError("Condition de stabilité non satisfaite : dt est trop grand !")
print(f"Gamma: {gamma:.5f}, Nu: {v:.5f}")

# Création des grilles d'espace et de temps
x = np.linspace(-L/2, L/2, Nx)
t = np.linspace(0, T, Nt)

# Initialisation de la solution
u = np.zeros((Nx, Nt))

def u_exacte(x,t):
    return t*np.exp(-x*x)  # fonction gaussienne

u[:, 0] = u_exacte(x,0)  # (t=0) condition initiale (température initiale)

#Source (calculée en fonction de la solution exacte cherchée)
def f(x,t):
    return np.exp(-x*x) - D * (2*t*np.exp(-x*x) * (2*x*x-1)) + C * (-2*x*t*np.exp(-x*x))

# Boucle en temps (schéma explicite)
plt.figure(figsize=(8, 6))
colors = plt.cm.jet(np.linspace(0, 1, 5+2)); idx = 1  # Génère Nt//5 couleurs distinctes

for n in range(0, Nt - 1):
    for i in range(1, Nx - 1):
        u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - v * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n]) # avec C > 0
        if(i==1): u[0,n+1] = u[1,n+1]
        if(i==Nt-2): u[Nt-1,n+1] = u[Nt-2,n+1]
    if n != 0 and n % (Nt // 5) == 0:
      plt.plot(x, u[:, n], label=f"Numérique t={t[n]:.2f}", color=colors[idx])
      plt.plot(x, u_exacte(x, t[n]), '--', label=f"Exacte t={t[n]:.2f}", color=colors[idx])
      idx+=1
plt.title("Comparaison solution numérique vs exacte")
plt.xlabel("Position")
plt.ylabel("température")
plt.grid()
plt.show()

# Calcul de l'erreur et de l'erreur relative au dernier instant
difference = u[:, n+1] - u_exacte(x, t[n+1])
diff_relative = (u[:, n+1] - u_exacte(x, t[n+1])) / abs(u_exacte(x, t[n+1]))
plt.figure(figsize=(10, 10))
# Premier graphe : Erreur absolue
plt.subplot(2, 1, 1)  # 2 lignes, 1 colonne, 1ère position
plt.plot(x, difference, label="Erreur absolue", color='red', linestyle='-', linewidth=2)
plt.title("Erreur absolue")
plt.xlabel("Position")
plt.ylabel("Erreur absolue")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
# Deuxième graphe : Erreur relative
plt.subplot(2, 1, 2)  # 2 lignes, 1 colonne, 2ème position
plt.plot(x, diff_relative, label="Erreur relative", color='blue', linestyle='--', linewidth=2)
plt.title("Erreur relative")
plt.xlabel("Position")
plt.ylabel("Erreur relative")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()  # Ajustement automatique des subplots
plt.show()

# Visualisation du résultat
plt.figure(figsize=(8, 6))
plt.imshow(u, aspect='auto', cmap='nipy_spectral', origin='lower', extent=[0, T, -L/2, L/2])
plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
plt.xlabel("Temps")
plt.ylabel("Position")
plt.colorbar(label='Température')
plt.show()

"""# Fonction gaussienne exp(-x*x*t)
Valeurs aux bords non nulles => on force l'anulation de la dérivée aux bords

"""

import numpy as np
import matplotlib.pyplot as plt

# Paramètres
L = 10          # Longueur de la barre
T = 10           # Temps final
D = 0.1      # Coefficient de diffusion
C = 0.1       # Vitesse de convection

# Discrétisation
Nx = 100         # Nombre de points dans l'espace
dx = L / (Nx-1) # Pas d'espace

# Condition de stabilité

gamma_1 = 1/4
v_1 = 1/2

dt1 = gamma_1 * (dx**2) / D
dt2 = v_1 * dx / np.abs(C)

dt = min(dt1, dt2)
gamma = dt * D / (dx**2)
v = dt * C /dx
Nt = int(T // dt)

if gamma > 0.5 or v > 1:
    raise ValueError("Condition de stabilité non satisfaite : dt est trop grand !")
print(f"Gamma: {gamma:.5f}, Nu: {v:.5f}")

# Création des grilles d'espace et de temps
x = np.linspace(-L/2, L/2, Nx)
t = np.linspace(0, T, Nt)

# Initialisation de la solution
u = np.zeros((Nx, Nt))

def u_exacte(x,t):
    return np.exp(-x*x*t)  # fonction gaussienne

u[:, 0] = u_exacte(x,0)  # (t=0) condition initiale (température initiale)

#Source (calculée en fonction de la solution exacte cherchée)
def f(x,t):
    return -x*x*np.exp(-x*x*t) - D * (2*t*np.exp(-x*x*t) * (2*t*x*x-1)) + C * (-2*x*t*np.exp(-x*x*t))

# Boucle en temps (schéma explicite)
plt.figure(figsize=(8, 6))
colors = plt.cm.jet(np.linspace(0, 1, 5+2)); idx = 1  # Génère Nt//5 couleurs distinctes

for n in range(0, Nt - 1):
    for i in range(1, Nx - 1):
        u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - v * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n]) # avec C > 0
        if(i==1): u[0,n+1] = u[1,n+1]
        if(i==Nt-2): u[Nt-1,n+1] = u[Nt-2,n+1]
    if n != 0 and n % (Nt // 5) == 0:
      plt.plot(x, u[:, n], label=f"Numérique t={t[n]:.2f}", color=colors[idx])
      plt.plot(x, u_exacte(x, t[n]), '--', label=f"Exacte t={t[n]:.2f}", color=colors[idx])
      idx+=1
plt.title("Comparaison solution numérique vs exacte")
plt.xlabel("Position")
plt.ylabel("température")
plt.grid()
plt.show()

# Visualisation du résultat
plt.figure(figsize=(8, 6))
plt.imshow(u, aspect='auto', cmap='nipy_spectral', origin='lower', extent=[0, T, -L/2, L/2])
plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
plt.xlabel("Temps")
plt.ylabel("Position")
plt.colorbar(label='Température')
plt.show()

"""**Erreur**"""

import numpy as np
import matplotlib.pyplot as plt

# Paramètres
L = 10          # Longueur de la barre
T = 10           # Temps final
D = 8   # Coefficient de diffusion
C = 5      # Vitesse de convection

# Discrétisation
Nx = 100         # Nombre de points dans l'espace
dx = L / (Nx-1) # Pas d'espace

# Condition de stabilité

gamma_1 = 1/4
v_1 = 1/2

dt1 = gamma_1 * (dx**2) / D
dt2 = v_1 * dx / np.abs(C)

dt = min(dt1, dt2)

gamma = dt * D / (dx**2)
v = dt * C /dx
Nt = int(T // dt)

if gamma > 0.5 or v > 1:
    raise ValueError("Condition de stabilité non satisfaite : dt est trop grand !")
print(f"Gamma: {gamma:.5f}, Nu: {v:.5f}")

# Création des grilles d'espace et de temps
x = np.linspace(-L/2, L/2, Nx)
t = np.linspace(0, T, Nt)

# Initialisation de la solution
u = np.zeros((Nx, Nt))

def u_exacte(x,t):
    return t*np.exp(-x*x)  # fonction gaussienne

u[:, 0] = u_exacte(x,0)  # (t=0) condition initiale (température initiale)

#Source (calculée en fonction de la solution exacte cherchée)
def f(x,t):
    return np.exp(-x*x) - D * (2*t*np.exp(-x*x) * (2*x*x-1)) + C * (-2*x*t*np.exp(-x*x))

# Boucle en temps (schéma explicite)
plt.figure(figsize=(8, 6))
colors = plt.cm.jet(np.linspace(0, 1, 5+2)); idx = 1  # Génère Nt//5 couleurs distinctes

# Liste pour stocker l'erreur au cours du temps
erreurs = []

for n in range(0, Nt - 1):
    for i in range(1, Nx - 1):
        u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - v * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n]) # avec C > 0
        u[0,n+1] = 0
        u[-1,n+1]=0

    if n != 0 and n % (Nt // 5) == 0:
      plt.plot(x, u[:, n], label=f"Numérique t={t[n]:.2f}", color=colors[idx])
      plt.plot(x, u_exacte(x, t[n]), '--', label=f"Exacte t={t[n]:.2f}", color=colors[idx])
      idx+=1

    # Calcul de l'erreur à ce temps t
    erreur = u[:, n+1] - u_exacte(x, t[n+1])
    erreurs.append(np.linalg.norm(erreur))  # Erreur L2

# Tracé de la courbe de l'erreur en fonction du temps
plt.figure(figsize=(8, 6))
plt.plot(erreurs, t[1:])
plt.title("Erreur L2 en fonction du temps")
plt.xlabel("Erreur L2")
plt.ylabel("Temps (t)")
plt.grid(True)
plt.legend()
plt.show()

# Visualisation du résultat
plt.figure(figsize=(8, 6))
plt.imshow(u, aspect='auto', cmap='nipy_spectral', origin='lower', extent=[0, T, -L/2, L/2])
plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
plt.xlabel("Temps")
plt.ylabel("Position")
plt.colorbar(label='Température')
plt.show()


# Normes
def norme_L2(erreur):
    return np.sqrt(dx * np.sum(erreur**2))

def norme_Linf(erreur):
    return np.max(np.abs(erreur))

print("Erreur relative L2 :", norme_L2(erreur) / np.linalg.norm(u_exacte(x, T)))
print("Erreur L∞ :", norme_Linf(erreur))

import numpy as np
import matplotlib.pyplot as plt

# Paramètres
L = 1          # Longueur de la barre
T = 100           # Temps final
D = 1     # Coefficient de diffusion
C = 1       # Vitesse de convection

# Discrétisation



# Condition de stabilité
dx1 = 1/10
dx2 = 1/20
dx3 = 1/40

dt = 0.9*min(dx1**2/2*D, dx2**2/2*D, dx3**2/2*D)
print("dt optimal =", dt)

print("calcul 1:", D * dt/dx1**2)
print("calcul 2:", D * dt/dx2**2)
print("calcul 3:", D * dt/dx3**2)


dx=dx2
Nx = int(L/dx +1)         # Nombre de points dans l'espace
gamma = D * (dt/(dx**2))
v = C * dt / dx

Nt = int(T // dt)

# Création des grilles d'espace et de temps
x = np.linspace(0, L, Nx)
t = np.linspace(0, T, Nt)
u = np.zeros((Nx, Nt))

def u_exacte(x,t):
    return np.sin(np.pi * x) * (1+t)

# Condition initiale (température initiale)
u[:, 0] = u_exacte(x,0)  # (t=0)

#Source
def f(x,t):
    return np.sin(np.pi * x) + D*((np.pi**2) * np.sin(np.pi * x) * (1+t)) + C * (np.pi * np.cos(np.pi * x) * (1+t))

plt.figure(figsize=(8, 6))
colors = plt.cm.plasma(np.linspace(0, 1, 5+1)); idx = 0  # Génère Nt//5 couleurs distinctes

# Boucle en temps (schéma explicite)
for n in range(0, Nt - 1):
    for i in range(1, Nx - 1):
        u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - v * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n])
    if n % (Nt // 5) == 0:
        plt.plot(x, u[:, n], label=f"Numérique t={t[n]:.2f}", color=colors[idx])
        plt.plot(x, u_exacte(x, t[n]), '--', label=f"Exacte t={t[n]:.2f}", color=colors[idx])
        idx+=1
plt.title("Comparaison solution numérique vs exacte")
plt.xlabel("Position")
plt.ylabel("température")
plt.grid()
plt.show()


# Normes
def norme_L2(erreur):
    return np.sqrt(dx * np.sum(erreur**2))

def norme_Linf(erreur):
    return np.max(np.abs(erreur))

#print("Erreur relative L2 :", norme_L2(erreur) / np.linalg.norm(u_exacte(x, T)))
#print("Erreur L∞ :", norme_Linf(erreur))



# Calcul de l'erreur et de l'erreur relative au dernier instant
difference = u[:, n+1] - u_exacte(x, t[n+1])
diff_relative = (u[:, n+1] - u_exacte(x, t[n+1])) / abs(u_exacte(x, t[n+1]))



plt.figure(figsize=(10, 10))
# Premier graphe : Erreur absolue
plt.subplot(2, 1, 1)  # 2 lignes, 1 colonne, 1ère position
plt.plot(x, difference, label="Erreur absolue", color='red', linestyle='-', linewidth=2)
plt.title("Erreur absolue")
plt.xlabel("Position")
plt.ylabel("Erreur absolue")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
# Deuxième graphe : Erreur relative
plt.subplot(2, 1, 2)  # 2 lignes, 1 colonne, 2ème position
plt.plot(x, diff_relative, label="Erreur relative", color='blue', linestyle='--', linewidth=2)
plt.title("Erreur relative")
plt.xlabel("Position")
plt.ylabel("Erreur relative")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()  # Ajustement automatique des subplots
plt.show()


# Visualisation du résultat
plt.figure(figsize=(8, 6))
plt.imshow(u, aspect='auto', cmap='hot', origin='lower', extent=[0, T, 0, L])
plt.colorbar(label='Température')
plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
plt.xlabel("Temps")
plt.ylabel("Position")
plt.show()

"""## Cas test : np.sin(np.pi * x) * (1+t)
- erreur en fonction de dx
"""

# -*- coding: utf-8 -*-
"""
Created on Wed Jan 22 15:56:36 2025

@author: Camille, Safia, Charlotte
"""

import numpy as np
import matplotlib.pyplot as plt

# Normes
def norme_L2(erreur):
    return np.sqrt(dx * np.sum(erreur**2))

def norme_Linf(erreur):
    return np.max(np.abs(erreur))


### Expérimentations

def u_exacte(x,t):
    return np.sin(np.pi * x) * (1+t)
def f(x,t): #Source
    return np.sin(np.pi * x) + D*((np.pi**2) * np.sin(np.pi * x) * (1+t)) + C * (np.pi * np.cos(np.pi * x) * (1+t))

## Paramètres
L = 1          # Longueur de la barre
T = 100           # Temps final
D = 0.01     # Coefficient de diffusion
C = 10       # Vitesse de convection
# Discrétisation
DX = np.array((1/40, 1/30, 1/20, 1/15, 1/10))
print("DX",DX)
dt = 0.9*np.min(DX)**2/2*D
print("dt optimal =", dt)
print("gamma:", D * dt/DX**2)
Nt = int(T // dt)
print("Nt:",Nt)
print("-----------------")

# initialisation erreur en fonction de dx
erreur_dx = np.zeros(len(DX))


for ind_erreur_dx, dx in enumerate(DX):
    print("dx:",dx)
    Nx = int(L/dx +1)         # Nombre de points dans l'espace
    print("Nx:",Nx)

    # Condition de stabilité
    gamma = D * (dt/(dx**2))
    v = C * dt / dx

    # Création des grilles d'espace et de temps
    x = np.linspace(0, L, Nx)
    t = np.linspace(0, T, Nt)
    u = np.zeros((Nx, Nt))

    # Pré-calcul de la solution exacte sur toute la grille (x, t)
    u_exacte_matrix = np.zeros((Nx, Nt))
    for n in range(Nt):
        u_exacte_matrix[:, n] = u_exacte(x, t[n])

    # Condition initiale (température initiale)
    u[:, 0] = u_exacte_matrix[:,0]  # (t=0)


    plt.figure(figsize=(8, 6))
    colors = plt.cm.plasma(np.linspace(0, 1, 5+1)); idx = 0  # Génère Nt//5 couleurs distinctes

    # Boucle en temps (schéma explicite)
    for n in range(0, Nt - 1):
        for i in range(1, Nx - 1):
            u[i, n+1] = u[i, n] + gamma * (u[i+1, n] - 2*u[i, n] + u[i-1, n]) - v * (u[i, n] - u[i-1, n]) + dt * f(x[i], t[n])
        if n % (Nt // 5) == 0:
            plt.plot(x, u[:, n], label=f"Numérique t={t[n]:.2f}", color=colors[idx])
            plt.plot(x, u_exacte(x, t[n]), '--', label=f"Exacte t={t[n]:.2f}", color=colors[idx])
            idx+=1
    plt.title("Comparaison solution numérique vs exacte")
    plt.xlabel("Position")
    plt.ylabel("température")
    plt.grid()
    plt.show()

    # Calcul de l'erreur globale
    erreur_dx[ind_erreur_dx] = norme_Linf(u[:, -1] - u_exacte_matrix[:, -1]) / np.max(np.abs(u_exacte_matrix[:, -1]))

    """
    # Calcul de l'erreur et de l'erreur relative au dernier instant
    difference = u[:, n+1] - u_exacte(x, t[n+1])
    diff_relative = (u[:, n+1] - u_exacte(x, t[n+1])) / abs(u_exacte(x, t[n+1]))
    plt.figure(figsize=(10, 10))
    # Premier graphe : Erreur absolue
    plt.subplot(2, 1, 1)  # 2 lignes, 1 colonne, 1ère position
    plt.plot(x, difference, label="Erreur absolue", color='red', linestyle='-', linewidth=2)
    plt.title("Erreur absolue")
    plt.xlabel("Position")
    plt.ylabel("Erreur absolue")
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.6)
    # Deuxième graphe : Erreur relative
    plt.subplot(2, 1, 2)  # 2 lignes, 1 colonne, 2ème position
    plt.plot(x, diff_relative, label="Erreur relative", color='blue', linestyle='--', linewidth=2)
    plt.title("Erreur relative")
    plt.xlabel("Position")
    plt.ylabel("Erreur relative")
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()  # Ajustement automatique des subplots
    plt.show()
    """

    # Visualisation du résultat
    plt.figure(figsize=(8, 6))
    plt.imshow(u, aspect='auto', cmap='hot', origin='lower', extent=[0, T, 0, L])
    plt.colorbar(label='Température')
    plt.title("Diffusion de la chaleur - Méthode des différences finies explicites")
    plt.xlabel("Temps")
    plt.ylabel("Position")
    plt.show()

    print("---")

# Erreurs relatives en fonction de dx avec annotations
plt.figure(figsize=(8, 6))
plt.loglog(DX, erreur_dx, marker='o', linestyle='-', color='purple', label="Erreur relative")
for i, (dx, err) in enumerate(zip(DX, erreur_dx)):
    plt.annotate(f"{err:.2e}", (dx, err), textcoords="offset points", xytext=(5, 5), ha='right')
plt.title("Erreur relative en fonction de dx")
plt.xlabel("dx (échelle logarithmique)")
plt.ylabel("Erreur relative (échelle logarithmique)")
plt.grid(which='both', linestyle='--', alpha=0.6)
plt.legend()
plt.show()

"""ERREUR EN FONCTION DU TEMPS"""